import random
from additional_functions import AdditionalFunctions
from romulus_encryption import RomulusEncryption
from tweakable_block_cipher import TweakableBlockCipher
from inverse_tweakable_block_cipher import InverseTweakableBlockCipher
from inverse_state_update_function import InverseStateUpdateFunction

#THIS CLASS GENERATED FOR ADVERSARY OPERATIONS
class RomulusAdversaryAttack:
    def __init__(self):
        self.additional_functions = AdditionalFunctions()
        self.inverse_state_update_function = InverseStateUpdateFunction()
        self.tweakable_block_cipher = TweakableBlockCipher()
        self.inverse_tweakable_block_cipher = InverseTweakableBlockCipher()
        self.romulus_encryption = RomulusEncryption()
        self.block_size = 16

        
    def adversary(self, key, nonce, associated_data, message):

        #Generate random key and nonce for the adversary operations
        rnd = self.additional_functions.random_bitstring
        random_key = bytes(rnd(48))
        random_nonce = bytes(rnd(16))
        
        #Ciphertext and tag that are tried to be reached after the adversary operations
        ciphertext, tag = self.romulus_encryption.encryption(key, nonce, associated_data, message)
        print("\nCiphertext and Tag that are tried to be reached after the adversary operations:\n\n" + "Ciphertext:" + ciphertext.hex() + "\n" + "Tag: " + bytes(tag).hex() + "\n")
        #Convert tag from byte to bits for using in the function
        tag_bits = self.additional_functions.bytes_to_bits(tag)
        
        #Use the same ciphertext and tag with different key and nonce to generate different state and plaintext
        forged_state, forged_plaintext = self.adversary_message(random_key, random_nonce, ciphertext, tag_bits)
        
        #Use the state that generated by adversary and generate an associated data
        forged_associated_data = self.adversary_context(random_key, random_nonce, forged_state)
        
        #Use generated associated data, plaintext and state and try to reach the same ciphertext and tag as before
        forged_ciphertext, forged_tag = self.romulus_encryption.encryption(random_key, random_nonce, forged_associated_data, forged_plaintext)
        print("Generated Ciphertext and Tag with using Generated Associated Data, Plaintext and State:\n\nForged Cipertext:" + forged_ciphertext.hex() + "\n" + "Forged Tag: " + bytes(forged_tag).hex()+ "\n")
        
        if forged_ciphertext == ciphertext and forged_tag == tag: 
            return True 
        else: 
            return False
        
    def adversary_message(self, key, nonce, ciphertext, tag_bits):
        """
        Recovers the plaintext and internal state from a given ciphertext and tag.
    
        Args:
        - key (bytes): The secret key.
        - nonce (bytes): The nonce used during encryption.
        - ciphertext (bytes): The ciphertext to be decrypted.
        - tag (list): The authentication tag used to reconstruct the internal state.
    
        Returns:
        - tuple: (final internal state, recovered plaintext blocks)
        """
        
        #Apply padding if necessary, divide into blocks and convert from byte to bit
        blocks = self.additional_functions.pad_L(ciphertext)
        blocks = self.additional_functions.divide_input_into_blocks(blocks)
        blocks = [self.additional_functions.bytes_to_bits(b) for b in blocks]
        
        #G-1(T) -> S
        state = self.inverse_state_update_function.invert_G(tag_bits)
        μ = len(blocks)
        plaintext = [None]*μ
        
        # Iterate through the ciphertext blocks in reverse
        for i in (range(μ - 1, -1, -1)):
                
            tweakey_bytes = self.tweakable_block_cipher.tweakey_encoding(
                key,
                nonce,
                self.tweakable_block_cipher.lfsr56_update(list((2 *i).to_bytes(7, 'little'))),
                is_last_block=(i == μ - 1),
                is_auth_phase=False,
                is_message_block=True,
                is_padded_ad=False,
                is_padded_msg=(len(ciphertext) % 16 != 0),
            )
            # Derive round tweakeys using the forward cipher
            #We need to use the "forward" cipher because we need the same tweakey bits as the encryption process
            _, round_tweakeys = self.tweakable_block_cipher.tweakable_block_cipher_bits(state, tweakey_bytes)
            
            # Decrypt using inverse TBC
            Y = self.call_inverse_tbc(state, round_tweakeys)
            
            # Recover the previous state and the message block
            state, M_i = self.inverse_state_update_function.inverse_state_update_function(Y, blocks[i])
            plaintext[i] = self.additional_functions.bits_to_bytes(M_i)
        
        #combine the all plaintext blocks in one block and take the same length as the ciphertext
        final_plaintext = b''.join(bytes(block) for block in plaintext)[:len(ciphertext)]
        return state, final_plaintext
    
    
    def adversary_context(self, key, nonce, final_state):
        """
        Constructs a valid associated data (AD) sequence that leads to a given internal state.
    
        Args:
        - key (bytes): The secret key.
        - nonce (bytes): The nonce used during encryption.
        - final_state (list): The final state from the message creating to match at the end of AD processing.
    
        Returns:
        - list: A forged associated data list that results in the desired state.
        """
        alpha = random.choice(range(2, 20, 2))  # Even number: α ∈ {2,4,6,...,18}
        associated_data = [None] * (alpha + 1)  # Indexing: A[0] to A[α]
        
        # Randomly choose A_α, A_{α-1}, ..., A₂
        for i in range(alpha - 1, 0, -1):
            associated_data[i] = self.additional_functions.bytes_to_bits(self.additional_functions.random_bitstring(16))
        
        #For the last block (the zero block that is used if ad is even -in adversary part ad is always even-)
        associated_data[alpha] = [0]*128
        
        #Take the input state as an initial state
        state = final_state
        
        #Generate tweakey bits
        tweakey_bytes = self.tweakable_block_cipher.tweakey_encoding(
                        key,
                        nonce,
                        self.tweakable_block_cipher.lfsr56_update(list((alpha - 1).to_bytes(7, 'little'))),
                        is_last_block=False,
                        is_auth_phase=True,
                        is_message_block=False,
                        is_padded_ad=False,
                        is_padded_msg=False,
        )
        
        #Use forward cipher to generate round tweakeys
        _, round_tweakeys = self.tweakable_block_cipher.tweakable_block_cipher_bits(state, tweakey_bytes) 
        
        #Apply inverse tweakable cipher
        state = self.call_inverse_tbc(state, round_tweakeys)

        # Iterate backward through AD pairs
        for i in range((alpha // 2) - 1, -1, -1):
            # 2. Y = state ⊕ A_2i+2 (generating states backwards with inverse state update function)

            Y = self.additional_functions.xor_vectors(state, associated_data[2*i+2])
            
            ad_even = associated_data[2*i+1] #Even blocks for TBC operations
            ad_even_bytes = self.additional_functions.bits_to_bytes(ad_even) #Odd blocks for State operations
            tweakey_bytes = self.tweakable_block_cipher.tweakey_encoding(
            key,
            ad_even_bytes,
            self.tweakable_block_cipher.lfsr56_update(list((2*i).to_bytes(7, 'little'))),
            is_last_block=(2*i+2 == alpha),
            is_auth_phase=True,
            is_message_block=False,
            is_padded_ad=False,
            is_padded_msg=False,
            )
            _, round_tweakeys = self.tweakable_block_cipher.tweakable_block_cipher_bits(Y, tweakey_bytes)
            state = self.call_inverse_tbc(Y, round_tweakeys)

            
        # Set the first block of AD to match recovered Y
        associated_data[0] = state
        
        #This operations are made for reaching the associated data as a byte string
        flat_bit_ad = [bit for sublist in associated_data[:alpha] for bit in sublist]
        byte_ad = self.additional_functions.bits_to_bytes(flat_bit_ad)
        byte_list_ad = bytes(byte_ad)
        return byte_list_ad
    
    #This function for calling inverse TBC function
    def call_inverse_tbc(self, state, round_tweakeys):
        state_bytes = self.additional_functions.bits_to_bytes(state)
        return self.inverse_tweakable_block_cipher.inverse_tweakable_cipher(state_bytes, round_tweakeys)
